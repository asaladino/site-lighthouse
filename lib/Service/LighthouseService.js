"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=void 0;var ChromeLauncher=_interopRequireWildcard(require("chrome-launcher"));var _lighthouse=_interopRequireDefault(require("lighthouse"));var _LighthouseDefault=_interopRequireDefault(require("../Config/LighthouseDefault"));var _printer=_interopRequireDefault(require("lighthouse/lighthouse-cli/printer"));var _UrlsRepository=_interopRequireDefault(require("../Repository/UrlsRepository"));var _OptionsRepository=_interopRequireDefault(require("../Repository/OptionsRepository"));var _Args=_interopRequireDefault(require("../Model/Args"));var _Option=_interopRequireDefault(require("../Model/Option"));var _Url=_interopRequireDefault(require("../Model/Url"));var _Progress=_interopRequireDefault(require("../Model/Progress"));var _path=_interopRequireDefault(require("path"));var _fs=_interopRequireDefault(require("fs"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{Promise.resolve(value).then(_next,_throw)}}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise(function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(undefined)})}}class LighthouseService{constructor(args){this.events=new Map;this.args=args;this.optionsRepository=new _OptionsRepository.default(this.args);this.option=this.optionsRepository.getOption();this.urlsRepository=new _UrlsRepository.default(this.option,this.args);this.createOutputFolder()}start(){var _this=this;return _asyncToGenerator(function*(){ChromeLauncher.launch({chromeFlags:["--headless","--disable-gpu","--no-sandbox"]}).then(chrome=>_this.runReports(chrome)).catch(reason=>console.log(reason))})()}runReports(chrome){var _this2=this;return _asyncToGenerator(function*(){let flags={};flags.port=chrome.port;let urls=_this2.urlsRepository.findAll().filter(url=>{return!_fs.default.existsSync(_path.default.join(_this2.folder,url.name+".json"))});let progress=new _Progress.default(null,urls.length);_this2.emitStart(progress);for(let url of urls){let results=yield(0,_lighthouse.default)(url.url,flags);yield _printer.default.write(JSON.stringify(results),"json",_path.default.join(_this2.folder,url.name+".json"));progress.update(url);_this2.emitProgress(progress)}_this2.emitComplete(new _Progress.default(null,urls.length));yield chrome.kill()})()}/**
     * Create the output folder if it doesn't exist.
     */createOutputFolder(){this.folder=_path.default.join(this.args.output.filename,this.args.getSiteName(),"lighthouse");if(!_fs.default.existsSync(this.folder)){_fs.default.mkdirSync(this.folder)}}/**
     * Receive event information.
     * @param event {string} name of the event. (start, progress, and complete)
     * @param callback {Function} called when the event is emitted.
     * @returns {LighthouseService} for chaining.
     */on(event,callback){this.events.set(event,callback);return this}/**
     * Emits that start event.
     * @param progress {Progress} found at start.
     */emitStart(progress){this.events.forEach((callback,event)=>{if(event==="start"){callback(progress)}})}/**
     * Emits that progress event.
     * @param progress {Progress} that is currently having its content extracted from.
     */emitProgress(progress){this.events.forEach((callback,event)=>{if(event==="progress"){callback(progress)}})}/**
     * Emits that complete event when service has finished.
     * @param progress {Progress} that we be done.
     */emitComplete(progress){this.events.forEach((callback,event)=>{if(event==="complete"){callback(progress)}})}}exports.default=LighthouseService;
//# sourceMappingURL=LighthouseService.js.map